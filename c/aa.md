什么是引用呢？从编译器的角度来看，就是从一个符号找到一个内存地址并读写其内容的过程。

## 符号表

```
int a = 3;
int *p = &a;
*p = 3;
int b[10];
```

| 符号 | 地址   | 类型  |
| ---- | ------ | ----- |
| a    | 0x1000 | int   |
| p    | 0x1004 | int*  |
| b    | 0x1008 | int[] |

在运行过程中，编译器发现a=3这句代码时，会在符号表里找a对应的地址，然后把3放入对应的地址，用一个式子表达为\*(0x1000)=3。

编译器遇到p=3时，首先要从符号表中找到变量p的地址0x1004，然后取出0x1004中的内容，这里为0x1000，最后把3放到0x1000内存地址中，即\*(\*0x1004)=3。

下面再来看一下指针加偏移量的引用方式，还以上面的指针p为例，让我们来看一下\*(p+2)=3的实现过程。首先，编译器从符号表中找到p然后，取出里面的内容0x2000，再根据其类型（int\*），做一个运算，0x2000+2×sizeof(int)=0x2008。所以编译器会把3放入0x2008这个内存地址。整个过程可表示为*(*(0x1004)+2\*4)=3。

那b[4]=3如何完成呢？首先，找到符号b，然后发现其类型为int[]（假想表达方式，C语言中不支持这样写），所以计算式变成了0x1008+4×sizeof(int)=0x1018，然后把3放入0x1018就可以了。用一个式子表达就\*(0x1008+4)=3

从上面的寻址式子可以看出，普通变量、指针、数组三者对于编译器的区别。具体到数组，它即具有普通变量的直接性，即不用取两次地址里的内容而是取一次，同时又具有和指针相同的偏移量引用方式，即下标的实现实际是由指针加偏移量实现的。

C语言对指针与数组的引用方式做了可以“交叉”使用的语法规定。就上面的例子来说，如果p指针指向数组b时，b[i]、\*(b+i)、p[i]、\*(p+i)都是对数组第i个元素的正确引用方式，这也给很多C语言学习者制造了“指针和数组一样”的错觉。

数组名大部分情况下在表达式中的值是数组首元素的地址，除了使用&和sizeof的情况。

数组名是一个常量，不允许对其进行赋值操作。

## &a

```
int a[10];
int *p = a;
int (*ap)[] = &a;  // 正确
p = &a;            // 错误
int **pp = &p;     // 正确
*pp = a;           // 正确 
```

指向数组的指针类型为int *[]，p应指向一个int变量的地址，而a是一个int数据，所以p = &a编译器会提示指针类型不相容（incompatible）。

## 如何理解数组和指针

对于数组，要明确每个元素的类型

对于指针，要明确指向的对象的类型

进行赋值时，根据这个原则检查类型是否相容。

举例说明一下。

```c
int arr[10];
int marr[2][10];
int *p;
int (*ap)[];
```

arr在表达式中是一个常量地址，但类型是(int *)，因为数组arr每个元素是int类型

marr在表达式中同样是一个地址，但类型是 int *[]，因为数组mrr是含有2个元素的数组，每个元素是int[10]（int []类型）。

p是int *类型，p = arr是正确的，因为arr在表达式中的结果就是一个常量地址，类型是int\*

p = &arr是错误的，&arr表示数组的地址（数组符号在&和sizeof中的含义与其他表达式不一样），类型为int []。

## 地址的类型

一个地址可以赋给哪种类型的指针，为了