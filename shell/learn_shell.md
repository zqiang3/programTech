cat /etc/shells
echo $SHELL

chsh -s 修改的就是/etc/passwd文件中和我们所登录的用户名相对应的那一行

## 第一个shell脚本

```shell
!/bin/bash

echo 'hello, world'
```



运行shell脚本
chmod +x test.sh  # 使脚本具有可执行权限
./test.sh

注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。

2、作为解释器参数
这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：
/bin/sh test.sh
/bin/php test.php



## 语法

```bash
# 注释
# 以#开头的行就是注释
# echo
echo "hello world"
# 变量
NAME="ZQ"      # 等号两边不能有空格
echo ${NAME}   # 大括号是可选的
readonly NAME  # 只读
unset NAME     # 删除变量，不能删除只读变量
# 变量类型
局部变量、环境变量、shell变量
# 字符串
str='this is a string'
str="hello, I know you are \"$your_name\"!"  # 双引号里可以有变量，可以出现转义字符
greeting="hello, "$your_name" !"             # 字符串拼接
echo ${#str}  # 输出字符串长度
# 数组
数组名=(值1 值2 ... 值n)  # 定义数组
echo ${数组名[下标]}      # 读取数组
echo ${array_name[@]}   # 读取数组所有元素
length=${#array_name[@]}  # 获取数组长度
length=${#array_name[*]}
```



## 链接

https://juejin.im/post/59f92f22f265da43356212a8

## 2.4.1 程序执行

Shell负责执行你在终端中指定的所有程序。每次输入一行内容，Shell就会分析该行，然后决定执行什么操作。就Shell而言，每一行都遵循以下基本格式：

```bash
program-name arguments
```



Shell使用一些特殊字符来确定程序名称及每个参数的起止。这些字符统称为空白字符（whitespace characters），它们包括空格符、水平制表符和行尾符（更正式的叫法是换行符）。连续的多个空白字符会被Shell忽略。



## 2.4.2 I/O重定向

```bash
echo Remember to record > reminder
```

Shell会识别出特殊的输出重定向字符`>`，然后将命令行中的下一个单词作为输出重定向所指向的文件名。在本例中，这个文件名为`reminder`。如果`reminder`已经存在且用户具有写权限，那么文件中已有的内容会被覆盖掉。如果没有该文件或其所在目录的写权限，Shell会产生错误信息。

```bash
$ wc -l users
      5 users
$ wc -l < users
      5
$
```

在第一个例子中，Shell解析命令行，确定要执行的程序名称是`wc`并为其传入两个参数：`-l`和`users`

当`wc`执行时，会看到传入的两个参数。第一个参数是`-l`，告诉它需要统计行数。第二个参数指定了待统计行数的文件。因此`wc`会打开文件`users`，统计行数，然后打印出结果及对应的文件名。

第二个例子中的`wc`操作略有不同。Shell在扫描命令行时发现了输入重定向字符`<`，其后的单词就被解释成从中重定向输入的文件名。从命令行中提取出了“`< users`”之后，Shell就开始执行`wc`程序，将其标准输入重定向为文件`users`并传入单个参数`-l`

这次当`wc`执行时，它会看到传入的单个参数`-l`。因为没有指定文件名，`wc`会转而去统计标准输入中内容的行数。因此`wc -l`在统计行数时，并不知道它实际上是在对文件`users`进行统计。最后的显示结果和平时一样，但是缺少了文件名，因为我们并没有为`wc`指定。

要理解两条命令在执行上的不同，这一点非常重要。

## 2.4.4 管道

```bash
who | wc -l
```

Shell在扫描命令行时，除了重定向符号之外还会查找管道字符|。每找到一个，就会将之前命令的标准输出连接到之后命令的标准输入，然后执行这两个命令。

Shell会查找分隔了命令`who`和`wc`的管道符号。它将上一个命令的标准输出连接到下一个命令的标准输入，然后执行两者。`who`命令执行时会生成已登录用户列表并将结果写入标准输出，它并不知道输出内容并没有出现在终端而是进入了另一个命令。

当`wc`命令执行时，它发现并没有指定文件名，因此就对标准输入内容进行统计，并没有意识到标准输入并非来自终端，而是来自于`who`命令的输出。

管道中并不仅限于有两条命令，你可以在复杂的管道中将3条、4条、5条甚至更多的命令串联在一起。这多少有点不好理解，但却是UNIX系统强大威力的所在。

## 2.4.6 解释型编程语言

Shell有自己内建的编程语言。这种语言是解释型的，也就是说，Shell会分析所遇到的每一条语句，然后执行所发现的有效的命令。这与C++及Swift这类编程语言不同，在这些语言中，程序语句在执行之前通常会被编译成可由机器执行的形式。

相较于编译型语言，由解释型语言所编写的程序一般要更易于调试和修改。然而，所花费的时间要比实现相同功能的编译型语言程序更长。

