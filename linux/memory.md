## 内存映射

内核为每个进程分配一个独立的虚拟地址空间。

虚拟地址空间内部又可分为内核空间和用户空间两部分。

32位地址空间，内核分配内存1g，用户空间分配3g。

既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以，并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存。

分配后的物理内存，是通过**内存映射**来管理的。

内存映射，其实就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系。

当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

当进程通过 malloc() 申请内存后，内存并不会立即分配，而是在首次访问时，才通过缺页异常陷入内核中分配内存。



## 分配内存的方式

malloc分配内存有两种方式，分别由两个系统调用完成: brk和mmap

1. brk是将数据段(.data)的最高地址指针往高地址推
2. mmap是在进程的虚拟地址空间中（堆和栈蹭，称为文件映射区）找一块空闲的虚拟内存。

两种方式分配的都是虚拟内存，并没有分配物理内存。什么时候分配物理内存叫做？在第 一次访问虚拟内存时，如果没有分配物理内存，会发生缺页中断，操作系统会负责分配物理内存，然后建立虚拟内存和物理内存之间的关系。

如果使用malloc分配了30K虚拟内存，但从来不访问它， 那么它对应的物理页是不会被分配的。

brk分配的内存需要等到高地址内存释放以后才能释放，

## 如何查看进程发生发生缺页中断的次数？

```
ps -o majflt,minflt -C program
```



## 查看内存使用情况

使用top命令查看进程使用的内存

* VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。
* RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。
* SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。
* %MEM 是进程使用物理内存占系统总内存的百分比。

## RSS

RSS: resident set size, 常驻内存集, 表示该进程**实际使用**的物理内存

RSS 是常驻内存集**Resident Set Size**，表示该进程分配的内存大小。

RSS 不包括进入交换分区的内存。

RSS 包括共享库占用的内存（只要共享库在内存中）

RSS 包括所有分配的栈内存和堆内存。

RSS 中有一部分来自共享库，而共享库可能被许多进程使用，所以如果把所有进程的 RSS 加起来，可能比系统内存还要大。

## VSZ 

VSZ表示进程分配的虚拟内存，包括进程已申请但未分配的内存。

VSZ 包括进程可以访问的所有内存，包括进入交换分区的内容，以及共享库占用的内存。



## 实例分析

如果一个进程，程序的大小有 500K，链接的共享库大小有 2500K，堆栈内存共有 200K，其中 100K 进入了交换分区。

进程实际加载了共享库中的 1000K 的内容，以及自己程序的中的 400K 的内容。请问 RSS 和 VSZ 应是多少？

RSS: 400K + 1000K + 100K = 1500K
 VSZ: 500K + 2500K + 200K = 3200K

