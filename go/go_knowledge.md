

go语言学习



UPDAT



\## import

包名和包路径并不需要完全一致

一个目录下只能有一个包

import只是导入了目录名，和包的名字没有任何关系

Import只是导入目录名，相当于添加了PATH变量



\## defer

1. 当defer被声明时，其参数就被实时解析
2. Defer的执行顺序为先进后出
3. 



\## 字符串

字符串类型是不可变的

尝试修改字符串内部数据的操作是被禁止的

两个十六进制是一个字节，三个八进制数也是一个字节

原生的字符串，反引号



\## 类型转换

Go语言不允许隐式类型转换



\## Printf

%v %+v %#v

%T 相应值的类型

%% 字面上的百分号

%t 布尔占位符

%b 二进制表示

%d %c %x %X

%p 指针占位符





\## 函数

函数的返回值，命名返回值即使只有一个，也需要使用()括起来



\## 方法

方法多了一个接受者



\## 接口

一个类型可以自由的使用另一个满足相同接口的类型来进行替换被称作可替换性，这是一个面向对象的特性。

一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。

一个类型属于某个接口只要这个类型实现这个接口

每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。



Go语言的起源





\## for

for initialization; condition; post {

​	// zero or more statements

}



\## 变量初始化

s := “” // 声明和赋值

var s string // 声明

var s string = “zq”

var s = “zq” // 自动推断



q := […]int{1, 2, 3}



\## if

{}是必须的，即便只有一条语句

If statement; condition {} // 在condition前会执行一条可选语句



\## switch

Case后自带break功能，匹配成功后不会执行其他case，如果需要执行后面的case，可以用fallthrough

Type Switch, 判断某个interface中实际存储的变量类型





\## new make

new是内建函数

func new(Type) *Type

new仅仅分配空间，传递给new函数的是一个类型，不是一个值。返回的是指向这个新分配的零值的指针。

// The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.



func make(Type, size …IntegerType) Type

make分配且初始化一个slice，或者map或者chan对象，只能是这三种对象。返回值就是这个类型（一个引用类型），而不是指针。



总结：new其实不常用，在现实的编码中，通常是采用短声明语句以及结构体的字面量达到我们的目的，这样更简洁方便，而且不会涉及到指针这种比较麻烦的操作。



\## 数组

数组的长度是固定的

数组之间可以用==或!=比较，但不同长度的数组是不同的类型，不能进行比较。

数组遍历 for i, value := range arr {}



\## 切片

切片添加元素的方法 append

reslice, 索引不可以超过slice切片的容量，越界不会使底层数组重新分配，而是报错



\## map

哈希表是一种巧妙并且实用的数据结构，可在常数时间复杂度内检索、更新或删除对应的value

Map中所有的key都有相同的类型，所有的value也有着相同的类型，但key和value可以是不同的数据类型。其中Key必须是支持==比较运算符的数据类型

删除 delete(m, “Alice”)

即使这些元素不在map中也没有关系，如果一个查找失败将返回value类型对应的零值。



\## channel

Channel是一个先进先出的队列



\## 结构体

Go不支持类，而是提供了结构体，结构体中可以添加方法，这样可以将数据和操作数据的方法绑定起来

结构体是值类型，因此可以通过new函数来创建

结构体通过.来访问内部的成员



点操作符也可以和指向结构体的指针一起工作



匿名成员，通过匿名成员可以把其他结构体嵌入进来



\## 短变量声明符

不能在函数外使用，不能用来声明全局变量

短变量声明符左边至少得有一个变量是没有定义过的



\## 指针

指针对于性能而言是不言而喻的

类型指针不能进行偏移和运算



C/C++语言中的裸指针可以自由偏移，甚至可以在某些情况下偏移进入操作系统的核心区域



\## interface{}

interface{}可以接受任意类型的对象值



\## 值类型与引用类型

Map slice channel 方法与函数是引用类型

对比python的可变类型与不可变类型

按引用传递实质上也是按值传递，传递的是指针的值，指针的值将被复制，但指针指向的地址的内容不会被复制



\## 单元测试

Go提供了很好有单元测试功能，单元测试只需新建一个以_test.go结尾的文件



\## unsafe.Sizeof



\## 类型别名在1.9引入

type handle int

type handle = int



\## 类型断言

类型断言是一个使用在接口值上的操作





## 概要

所有代码都可在下面的仓库获得。

http://gopl.io

包的概

摒弃模块接口文件和模块实现文件的区别

顺序通信进程

没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，没有继承，没有泛型，没有异常，没有宏，没有函数修饰

保证向后兼容

轻量级线程goroutine，创建百万级的goroutine是可行的

没有类层次结构，甚至可以说没有类



## go程序的执行过程

1. 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：
2. 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。
3. 然后以相反的顺序在每个包中初始化常量和变量，**如果该包含有 init 函数的话，则调用该函数**。
4. 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。

## go程序的编译

Go语言的程序编写基本以源码方式，无论是自己的代码还是第三方代码，并且以 GOPATH 作为工作目录和一套完整的工程目录规则。因此 Go语言中日常编译时无须像 [C++](http://c.biancheng.net/cplus/) 一样配置各种包含路径、链接库地址等。

go build 有很多种编译方法，如无参数编译、文件列表编译、指定包编译等，使用这些方法都可以输出可执行文件。

### 无参数编译

go build 在编译开始时，会搜索当前目录的 go 源码。假定aaa目录下有main.go, lib.go。go build 会找到 lib.go 和 main.go 两个文件。编译这两个文件后，生成当前目录名的可执行文件并放置于当前目录下，这里的可执行文件是 aaa。

### 文件列表编译

编译同目录的多个源码文件时，可以在 go build 的后面提供多个文件名，go build 会编译这些源码，输出可执行文件。

编译后的可执行文件变成了main。使用“go build+文件列表”方式编译时，可执行文件默认选择文件列表中第一个源码文件作为可执行文件名输出。如果需要指定输出可执行文件名，可以使用`-o`参数。

使用“go build+文件列表”编译方式编译时，文件列表中的每个文件必须是同一个包的 Go 源码。“go build+文件列表”方式更适合使用 Go 语言编写的只有少量文件的工具。

### 指定包编译

`-o`执行指定输出文件为 main，后面接要编译的包名。包名是相对于 GOPATH 下的 src 目录开始的。

注意 GOPATH 下的目录结构，源码必须放在 GOPATH 下的 src 目录下。所有目录中不要包含中文。

### 附加参数

| 附加参数 | 备  注                                      |
| -------- | ------------------------------------------- |
| -v       | 编译时显示包名                              |
| -p n     | 开启并发编译，默认情况下该值为 CPU 逻辑核数 |
| -a       | 强制重新构建                                |
| -n       | 打印编译时会用到的所有命令，但不真正执行    |
| -x       | 打印编译时会用到的所有命令                  |
| -race    | 开启竞态检测                                |

## 特殊规定

左大括号 `{` 必须与方法的声明放在同一行，这是编译器的强制规定 

**Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成** 

## 注释

单行注释：//

多行注释：/* */

## 命名空间、包

如果main 包的源代码没有包含main函数，则会引发构建错误 `undefined: main.main` 

main 函数即没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了参数或者返回类型，将会引发构建错误

## 常量

常量：const，变量：var

在 Go 语言中，你可以省略类型说明符 `[type]`，因为编译器可以根据变量的值来推断其类型

```go
const b string = "abc"
const b = "abc"
```

## 变量

Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go 为什么要选择这么做呢？ 

首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：`int* a, b;`。 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。 

Go 编译器可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在**编译时**就已经完成推断过程。 

当你在函数体内声明局部变量时，应使用简短声明语法 `:=` 。这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。 

如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误 。但是全局变量是允许声明但不使用。 

**并行赋值**

空白标识符 `_` 也被用于抛弃值，如值 `5` 在：`_, b = 5, 7` 中被抛弃。 

记住，所有的内存在 Go 中都是经过初始化的。 

变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：`numShips` 和 `startDate`。 

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（第 4.2 节：可见性规则）。 

## 可见性规则

## 作用域

如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。 

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量 

for 这些控制结构，而在这些结构中声明的变量的作用域只在相应的代码块内。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。 

## init函数

变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。 

 ## iota

`iota` 也可以用在表达式中，如：`iota + 50`。在每遇到一个新的常量块或单个常量声明时， `iota` 都会重置为 0（ **简单地讲，每遇到一次 const 关键字，iota 就重置为 0** ） 

```go
type Color int

const (
    RED Color = iota
    ORANGE
    YELLO
    GREEN
    BLUE
)
```

## 数据类型

int float bool string

struct array slice map channel

每个类型都定义了可以和自己结合的运算符集合，如果你使用了不在这个集合中的运算符，则会在编译时获得编译错误。 

一元运算符只可以用于一个值的操作（作为后缀），而二元运算符则可以和两个值或者操作数结合（作为中缀）。 

只有两个类型相同的值才可以和二元运算符结合，另外要注意的是，Go 是强类型语言，因此不会进行隐式转换，任何不同类型之间的转换都必须显式说明（第 4.2 节）。 

布尔型的值只可以是常量 true 或者 false。 

## rune类型

link: https://juejin.im/post/5b44caebf265da0f491b8b83

```
// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.

//int32的别名，几乎在所有方面等同于int32
//它用来区分字符值和整数值

type rune = int32

```



```go
package main

import "fmt"

func main() {

	var str = "hello 你好"
	fmt.Println("len(str):", len(str))

}
```



golang中string底层是通过byte数组实现的。中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8。




## 布尔型与逻辑运算符

在格式化输出时，你可以使用 `%t` 来表示你要输出的值为布尔型 

对于布尔值的好的命名能够很好地提升代码的可读性，例如以 `is` 或者 `Is` 开头的`isSorted`、`isFinished`、`isVisivle`，使用这样的命名能够在阅读代码的获得阅读正常语句一样的良好体验，例如标准库中的 `unicode.IsDigit(ch)` 

`&&`、或 `||` 与相等 `==` 或不等 `!=` 属于二元运算符，而非 `!` 属于一元运算符。 

在 Go 语言中，&& 和 || 是具有快捷性质的运算符，当运算符左边表达式的值已经能够决定整个表达式的值的时候（&& 左边的值为 false，|| 左边的值为 true），运算符右边的表达式将不会被执行。利用这个性质，如果你有多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧以减少不必要的运算。 

## 字符

Go语言同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。



字符使用单引号括起来，`\x` 总是紧跟着长度为 2 的 16 进制数 

另外一种可能的写法是 `\` 后面紧跟着长度为 3 的十进制数，例如：`\377` 

byte 是 uint8的别名

因为 Unicode 至少占用 2 个字节，所以我们使用 `int16` 或者 `int` 类型来表示。如果需要使用到 4 字节，则会加上 `\U`前缀；前缀 `\u` 则总是紧跟着长度为 4 的 16 进制数，前缀 `\U` 紧跟着长度为 8 的 16 进制数。 

格式化说明符 `%c` 用于表示字符；当和字符配合使用时，`%v` 或 `%d` 会输出用于表示该字符的整数；`%U` 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）。

包 `unicode` 包含了一些针对测试字符的非常有用的函数（其中 `ch` 代表字符）：

- 判断是否为字母：`unicode.IsLetter(ch)`
- 判断是否为数字：`unicode.IsDigit(ch)`
- 判断是否为空白符号：`unicode.IsSpace(ch)`

## 类型转换

```go
a := 5.0
b := int(a)
```

## 字符串

Go 中的字符串是根据长度限定，而非特殊字符`\0` 

任何类型 **T** 转换为字符串总是成功的 

## 控制结构

Go 完全省略了 `if`、`switch` 和 `for` 结构中条件语句两侧的括号 

if 即使当代码块之间只有一条语句时，大括号也不可被省略(尽管有些人并不赞成，但这还是符合了软件工程原则的主流做法)。 

关键字 if 和 else 之后的左大括号 `{` 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 `}` 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。 

**if-else**

但要注意的是，使用简短方式 `:=` 声明的变量的作用域只存在于 if 结构中（在 if 结构的大括号之间，如果使用 if-else 结构则在 else 代码块中变量也会存在） 

**switch**

类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式 .

您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：`case val1, val2, val3` 

switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件 

**for**

`for (i = 0; i < 10; i++) { }`，这是无效的代码 

## 函数

只有当某个函数需要被外部包调用的时候才使用大写字母开头 

```go
func FunctionName(a typea, b typeb) typeFunc
```

如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。

实参通过传值的方式传递。

函数的形参是实参的拷贝，对形参的修改不会影响实参。

如果实参包含引用类型，实参可能由于间接引用而被修改

大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。go使用可变栈，栈的大小按需增加（初始时很小）。

**多值返回**：多值返回是Go的一大特性，python其实也可以返回多个值，只不过返回值被组合在一个元组了。

按值传递与按引用传递

有些函数没有返回值，我们只是利用函数的副作用，这种函数通常也称为方法。

**命名返回值**

** 尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂 **

```go
func Foo(input int) (a int, b int) {
    a = 2 * input
    b = 3 * input
    return
}

```

空白符：空白符用来匹配不需要的值，然后丢弃掉

改变外部变量：采用传递指针的方式

传递变长参数：参数类型相同，参数类型不同

```go
func min(a ...int) int {  // a 的类型是 []int
    if len(a) == 0 {
        return 0
    }

    min := a[0]
    for _, v := range a {
        if v < min {
            min = v
        }
    }
    return min
}
```

**defer**

关键字defer允许我们执行一些收尾工作

合理使用defer可以使代码更简洁



## 方法

```go
type Student struct {
  name string
  age int
}

func (s *Student) Hello() {
  fmt.Println("hello")
}
```



## 依赖包

随着Go 1.5 release版本的发布，vendor目录被添加到除了GOPATH和GOROOT之外的查找依赖目录。在Go 1.6之前，你需要手动的设置环境变量`GO15VENDOREXPERIMENT=1`才可以使Go找到Vendor目录，然而在Go 1.6之后，这个功能已经不需要配置环境变量就可以实现了。

## go test

文件名必须以`_test.go`结尾。

方法名须以"Test"打头，并且形参为 (t *testing.T)

测试整个文件：$ go test -v hello_test.go

测试单个函数：$ go test -v hello_test.go -test.run TestHello



## Context

控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context。



## 结构体

定义结构体和C语言一样，使用struct关键字。在结构体内部定义它们的成员变量和类型，只是类型要放到后面，并且**变量之间不用逗号**。如果成员变量的类型相同的话，可以把它们写到同一行。

```go
type Rect struct {
  x, y float64
  width, height float64
}
```



初始化方法：

```go
rect1 := new(Rect)
rect2 := &Rect{}
rect3 := &Rect{0, 0, 100, 200}           // 按照字段顺序进行初始化
rect4 := &Rect{width: 100, height: 200}  // 通过 field:value 形式初始化
```

注意这几个变量全部为指向Rect结构的指针(指针变量)，因为使用了new()函数和&操作符．而如果使用方法

`a := Rect{}`则表示这个是一个`Rect{}`类型．两者是不一样的．参考代码：

```go
func main() {
  rect1 := &Rect{0, 0, 100, 200}
  rect1.x = 10  // Go语言自带隐式解引用
  a := Rect{}
  a.x = 15

  fmt.Printf("%v\n%T\n", a, a)
  fmt.Printf("%v\n%T\n", rect1, rect1)
}
```



运行结果为:

{15 0 0 0}

 main.Rect

 &{10 0 100 200}

 *main.Rect

从结果中可以清楚的看到两者的不同．

## 指针

在Go语言中，直接砍掉了C语言指针最复杂的指针运算部分，只留下了获取指针（&运算符）和获取对象（*运算符）的运算，使用方法和C语言很类似。但不同的是，Go语言中**没有 -> 操作符**来调用指针所属的成员，而与一般对象一样，都是使用`.`来调用

Go语言自带指针隐式解引用 ：对于一些复杂类型的指针， 如果要访问成员变量时候需要写成类似 *p.field的形式时，只需要p.field即可访问相应的成员。

## make

```go
func make(Type, size IntegerType) Type
```

> The make built-in function **allocates and initializes an object（分配空间 + 初始化）** of type slice, map or chan**(only)**. Like new , the first arguement is a type, not a value. Unlike new, make’s return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type.



> ```
> Slice : 第二个参数 size 指定了它的长度，此时它的容量和长度相同。
> 你可以传入第三个参数 来指定不同的容量值，但是必须不能比长度值小。
> 比如: make([]int, 0, 10)
> Map: 根据size 大小来初始化分配内存，不过分配后的 map 长度为0。 如果 size 被忽略了，那么会在初始化分配内存的时候 分配一个小尺寸的内存。
> Channel: 管道缓冲区依据缓冲区容量被初始化。如果容量为 0 或者被 忽略，管道是没有缓冲区的。
> ```



## 数组打散

‘…’ 其实是go的一种语法糖。
它的第一个用法主要是用于函数有多个不定参数的情况，可以接受多个不确定数量的参数。
第二个用法是slice可以被打散进行传递。

```go
package main
import "fmt"

func main() {
    lines := []string {"aaa", "bbb", "fff",}
    fmt.Println(lines)
    testArray("haha", "wawa", "ccc")
}

func testArray(args ...string) {
    for _, arg := range args {
        fmt.Println(arg)
    }
}
```

