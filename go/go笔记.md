## go程序的执行过程

1. 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：
2. 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。
3. 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。
4. 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。

## 特殊规定

左大括号 `{` 必须与方法的声明放在同一行，这是编译器的强制规定 

**Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成** 

## 注释

单行注释：//

多行注释：/* */

## 命名空间、包

如果main 包的源代码没有包含main函数，则会引发构建错误 `undefined: main.main` 

main 函数即没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了参数或者返回类型，将会引发构建错误

## 常量

常量：const，变量：var

在 Go 语言中，你可以省略类型说明符 `[type]`，因为编译器可以根据变量的值来推断其类型

```go
const b string = "abc"
const b = "abc"
```

## 变量

Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go 为什么要选择这么做呢？ 

首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：`int* a, b;`。 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。 

Go 编译器可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在**编译时**就已经完成推断过程。 

当你在函数体内声明局部变量时，应使用简短声明语法 `:=` 。这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。 

如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误 。但是全局变量是允许声明但不使用。 

**并行赋值**

空白标识符 `_` 也被用于抛弃值，如值 `5` 在：`_, b = 5, 7` 中被抛弃。 

记住，所有的内存在 Go 中都是经过初始化的。 

变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：`numShips` 和 `startDate`。 

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（第 4.2 节：可见性规则）。 

## 可见性规则

## 作用域

如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。 

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量 

for 这些控制结构，而在这些结构中声明的变量的作用域只在相应的代码块内。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。 

## init函数

变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。 

 ## iota

`iota` 也可以用在表达式中，如：`iota + 50`。在每遇到一个新的常量块或单个常量声明时， `iota` 都会重置为 0（ **简单地讲，每遇到一次 const 关键字，iota 就重置为 0** ） 

```go
type Color int

const (
    RED Color = iota
    ORANGE
    YELLO
    GREEN
    BLUE
)
```

## 数据类型

int float bool string

struct array slice map channel

每个类型都定义了可以和自己结合的运算符集合，如果你使用了不在这个集合中的运算符，则会在编译时获得编译错误。 

一元运算符只可以用于一个值的操作（作为后缀），而二元运算符则可以和两个值或者操作数结合（作为中缀）。 

只有两个类型相同的值才可以和二元运算符结合，另外要注意的是，Go 是强类型语言，因此不会进行隐式转换，任何不同类型之间的转换都必须显式说明（第 4.2 节）。 

布尔型的值只可以是常量 true 或者 false。 

## 布尔型与逻辑运算符

在格式化输出时，你可以使用 `%t` 来表示你要输出的值为布尔型 

对于布尔值的好的命名能够很好地提升代码的可读性，例如以 `is` 或者 `Is` 开头的`isSorted`、`isFinished`、`isVisivle`，使用这样的命名能够在阅读代码的获得阅读正常语句一样的良好体验，例如标准库中的 `unicode.IsDigit(ch)` 

`&&`、或 `||` 与相等 `==` 或不等 `!=` 属于二元运算符，而非 `!` 属于一元运算符。 

在 Go 语言中，&& 和 || 是具有快捷性质的运算符，当运算符左边表达式的值已经能够决定整个表达式的值的时候（&& 左边的值为 false，|| 左边的值为 true），运算符右边的表达式将不会被执行。利用这个性质，如果你有多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧以减少不必要的运算。 

## 字符

字符使用单引号括起来，`\x` 总是紧跟着长度为 2 的 16 进制数 

另外一种可能的写法是 `\` 后面紧跟着长度为 3 的十进制数，例如：`\377` 

byte 是 uint8的别名

因为 Unicode 至少占用 2 个字节，所以我们使用 `int16` 或者 `int` 类型来表示。如果需要使用到 4 字节，则会加上 `\U`前缀；前缀 `\u` 则总是紧跟着长度为 4 的 16 进制数，前缀 `\U` 紧跟着长度为 8 的 16 进制数。 

格式化说明符 `%c` 用于表示字符；当和字符配合使用时，`%v` 或 `%d` 会输出用于表示该字符的整数；`%U` 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）。

包 `unicode` 包含了一些针对测试字符的非常有用的函数（其中 `ch` 代表字符）：

- 判断是否为字母：`unicode.IsLetter(ch)`
- 判断是否为数字：`unicode.IsDigit(ch)`
- 判断是否为空白符号：`unicode.IsSpace(ch)`

## 类型转换

```go
a := 5.0
b := int(a)
```

## 字符串

Go 中的字符串是根据长度限定，而非特殊字符`\0` 

任何类型 **T** 转换为字符串总是成功的 

## 控制结构

Go 完全省略了 `if`、`switch` 和 `for` 结构中条件语句两侧的括号 

if 即使当代码块之间只有一条语句时，大括号也不可被省略(尽管有些人并不赞成，但这还是符合了软件工程原则的主流做法)。 

关键字 if 和 else 之后的左大括号 `{` 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 `}` 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。 

** if - else**

但要注意的是，使用简短方式 `:=` 声明的变量的作用域只存在于 if 结构中（在 if 结构的大括号之间，如果使用 if-else 结构则在 else 代码块中变量也会存在） 

**switch**

类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式 .

您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：`case val1, val2, val3` 

switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件 

**for**

`for (i = 0; i < 10; i++) { }`，这是无效的代码 

## 函数

只有当某个函数需要被外部包调用的时候才使用大写字母开头 

```go
func FunctionName(a typea, b typeb) typeFunc
```

