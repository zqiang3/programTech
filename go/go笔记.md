## 概要

所有代码都可在下面的仓库获得。

http://gopl.io

包的概

摒弃模块接口文件和模块实现文件的区别

顺序通信进程

没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，没有继承，没有泛型，没有异常，没有宏，没有函数修饰

保证向后兼容

轻量级线程goroutine，创建百万级的goroutine是可行的

没有类层次结构，甚至可以说没有类



## go程序的执行过程

1. 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：
2. 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。
3. 然后以相反的顺序在每个包中初始化常量和变量，**如果该包含有 init 函数的话，则调用该函数**。
4. 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。

## go程序的编译

Go语言的程序编写基本以源码方式，无论是自己的代码还是第三方代码，并且以 GOPATH 作为工作目录和一套完整的工程目录规则。因此 Go语言中日常编译时无须像 [C++](http://c.biancheng.net/cplus/) 一样配置各种包含路径、链接库地址等。

go build 有很多种编译方法，如无参数编译、文件列表编译、指定包编译等，使用这些方法都可以输出可执行文件。

### 无参数编译

go build 在编译开始时，会搜索当前目录的 go 源码。假定aaa目录下有main.go, lib.go。go build 会找到 lib.go 和 main.go 两个文件。编译这两个文件后，生成当前目录名的可执行文件并放置于当前目录下，这里的可执行文件是 aaa。

### 文件列表编译

编译同目录的多个源码文件时，可以在 go build 的后面提供多个文件名，go build 会编译这些源码，输出可执行文件。

编译后的可执行文件变成了main。使用“go build+文件列表”方式编译时，可执行文件默认选择文件列表中第一个源码文件作为可执行文件名输出。如果需要指定输出可执行文件名，可以使用`-o`参数。

使用“go build+文件列表”编译方式编译时，文件列表中的每个文件必须是同一个包的 Go 源码。“go build+文件列表”方式更适合使用 Go 语言编写的只有少量文件的工具。

### 指定包编译

`-o`执行指定输出文件为 main，后面接要编译的包名。包名是相对于 GOPATH 下的 src 目录开始的。

注意 GOPATH 下的目录结构，源码必须放在 GOPATH 下的 src 目录下。所有目录中不要包含中文。

### 附加参数

| 附加参数 | 备  注                                      |
| -------- | ------------------------------------------- |
| -v       | 编译时显示包名                              |
| -p n     | 开启并发编译，默认情况下该值为 CPU 逻辑核数 |
| -a       | 强制重新构建                                |
| -n       | 打印编译时会用到的所有命令，但不真正执行    |
| -x       | 打印编译时会用到的所有命令                  |
| -race    | 开启竞态检测                                |

## 特殊规定

左大括号 `{` 必须与方法的声明放在同一行，这是编译器的强制规定 

**Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成** 

## 注释

单行注释：//

多行注释：/* */

## 命名空间、包

如果main 包的源代码没有包含main函数，则会引发构建错误 `undefined: main.main` 

main 函数即没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了参数或者返回类型，将会引发构建错误

## 常量

常量：const，变量：var

在 Go 语言中，你可以省略类型说明符 `[type]`，因为编译器可以根据变量的值来推断其类型

```go
const b string = "abc"
const b = "abc"
```

## 变量

Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go 为什么要选择这么做呢？ 

首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：`int* a, b;`。 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。 

Go 编译器可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在**编译时**就已经完成推断过程。 

当你在函数体内声明局部变量时，应使用简短声明语法 `:=` 。这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。 

如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误 。但是全局变量是允许声明但不使用。 

**并行赋值**

空白标识符 `_` 也被用于抛弃值，如值 `5` 在：`_, b = 5, 7` 中被抛弃。 

记住，所有的内存在 Go 中都是经过初始化的。 

变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：`numShips` 和 `startDate`。 

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（第 4.2 节：可见性规则）。 

## 可见性规则

## 作用域

如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。 

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量 

for 这些控制结构，而在这些结构中声明的变量的作用域只在相应的代码块内。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。 

## init函数

变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。 

 ## iota

`iota` 也可以用在表达式中，如：`iota + 50`。在每遇到一个新的常量块或单个常量声明时， `iota` 都会重置为 0（ **简单地讲，每遇到一次 const 关键字，iota 就重置为 0** ） 

```go
type Color int

const (
    RED Color = iota
    ORANGE
    YELLO
    GREEN
    BLUE
)
```

## 数据类型

int float bool string

struct array slice map channel

每个类型都定义了可以和自己结合的运算符集合，如果你使用了不在这个集合中的运算符，则会在编译时获得编译错误。 

一元运算符只可以用于一个值的操作（作为后缀），而二元运算符则可以和两个值或者操作数结合（作为中缀）。 

只有两个类型相同的值才可以和二元运算符结合，另外要注意的是，Go 是强类型语言，因此不会进行隐式转换，任何不同类型之间的转换都必须显式说明（第 4.2 节）。 

布尔型的值只可以是常量 true 或者 false。 

## 布尔型与逻辑运算符

在格式化输出时，你可以使用 `%t` 来表示你要输出的值为布尔型 

对于布尔值的好的命名能够很好地提升代码的可读性，例如以 `is` 或者 `Is` 开头的`isSorted`、`isFinished`、`isVisivle`，使用这样的命名能够在阅读代码的获得阅读正常语句一样的良好体验，例如标准库中的 `unicode.IsDigit(ch)` 

`&&`、或 `||` 与相等 `==` 或不等 `!=` 属于二元运算符，而非 `!` 属于一元运算符。 

在 Go 语言中，&& 和 || 是具有快捷性质的运算符，当运算符左边表达式的值已经能够决定整个表达式的值的时候（&& 左边的值为 false，|| 左边的值为 true），运算符右边的表达式将不会被执行。利用这个性质，如果你有多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧以减少不必要的运算。 

## 字符

字符使用单引号括起来，`\x` 总是紧跟着长度为 2 的 16 进制数 

另外一种可能的写法是 `\` 后面紧跟着长度为 3 的十进制数，例如：`\377` 

byte 是 uint8的别名

因为 Unicode 至少占用 2 个字节，所以我们使用 `int16` 或者 `int` 类型来表示。如果需要使用到 4 字节，则会加上 `\U`前缀；前缀 `\u` 则总是紧跟着长度为 4 的 16 进制数，前缀 `\U` 紧跟着长度为 8 的 16 进制数。 

格式化说明符 `%c` 用于表示字符；当和字符配合使用时，`%v` 或 `%d` 会输出用于表示该字符的整数；`%U` 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）。

包 `unicode` 包含了一些针对测试字符的非常有用的函数（其中 `ch` 代表字符）：

- 判断是否为字母：`unicode.IsLetter(ch)`
- 判断是否为数字：`unicode.IsDigit(ch)`
- 判断是否为空白符号：`unicode.IsSpace(ch)`

## 类型转换

```go
a := 5.0
b := int(a)
```

## 字符串

Go 中的字符串是根据长度限定，而非特殊字符`\0` 

任何类型 **T** 转换为字符串总是成功的 

## 控制结构

Go 完全省略了 `if`、`switch` 和 `for` 结构中条件语句两侧的括号 

if 即使当代码块之间只有一条语句时，大括号也不可被省略(尽管有些人并不赞成，但这还是符合了软件工程原则的主流做法)。 

关键字 if 和 else 之后的左大括号 `{` 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 `}` 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。 

**if-else**

但要注意的是，使用简短方式 `:=` 声明的变量的作用域只存在于 if 结构中（在 if 结构的大括号之间，如果使用 if-else 结构则在 else 代码块中变量也会存在） 

**switch**

类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式 .

您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：`case val1, val2, val3` 

switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件 

**for**

`for (i = 0; i < 10; i++) { }`，这是无效的代码 

## 函数

只有当某个函数需要被外部包调用的时候才使用大写字母开头 

```go
func FunctionName(a typea, b typeb) typeFunc
```

如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。

实参通过传值的方式传递。

函数的形参是实参的拷贝，对形参的修改不会影响实参。

如果实参包含引用类型，实参可能由于间接引用而被修改

大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。go使用可变栈，栈的大小按需增加（初始时很小）。

**多值返回**：多值返回是Go的一大特性，python其实也可以返回多个值，只不过返回值被组合在一个元组了。

按值传递与按引用传递

有些函数没有返回值，我们只是利用函数的副作用，这种函数通常也称为方法。

**命名返回值**

** 尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂 **

```go
func Foo(input int) (a int, b int) {
    a = 2 * input
    b = 3 * input
    return
}

```

空白符：空白符用来匹配不需要的值，然后丢弃掉

改变外部变量：采用传递指针的方式

传递变长参数：参数类型相同，参数类型不同

```go
func min(a ...int) int {  // a 的类型是 []int
    if len(a) == 0 {
        return 0
    }

    min := a[0]
    for _, v := range a {
        if v < min {
            min = v
        }
    }
    return min
}
```

**defer**

关键字defer允许我们执行一些收尾工作

合理使用defer可以使代码更简洁

## 依赖包

随着Go 1.5 release版本的发布，vendor目录被添加到除了GOPATH和GOROOT之外的查找依赖目录。在Go 1.6之前，你需要手动的设置环境变量`GO15VENDOREXPERIMENT=1`才可以使Go找到Vendor目录，然而在Go 1.6之后，这个功能已经不需要配置环境变量就可以实现了。

## go test

文件名必须以`_test.go`结尾。

方法名须以"Test"打头，并且形参为 (t *testing.T)

测试整个文件：$ go test -v hello_test.go

测试单个函数：$ go test -v hello_test.go -test.run TestHello



## Context

控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context。